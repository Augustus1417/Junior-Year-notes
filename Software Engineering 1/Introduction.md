# ðŸ“˜ Software & Software Engineering  
	
## ðŸ–¥ï¸ Software  

> [!note] **What is Software?**  
> - **Instructions** â†’ computer programs  
> - **Data structures** â†’ store & manipulate information  
> - **Documentation** â†’ describes operation & usage  

---

### ðŸ“‚ Categories of Software  

| **Category**               | **Description**                                                                 |
| -------------------------- | ------------------------------------------------------------------------------- |
| **System**                 | Manages hardware & system operations (e.g., compilers, editors, file utilities) |
| **Application**            | End-user tasks (e.g., word processors, accounting software)                      |
| **Engineering/Scientific** | Heavy computation (e.g., stress analysis, molecular modeling)                   |
| **Embedded**               | Built into devices for control (e.g., microwave, car dashboard)                 |
| **Product-Line**           | Consumer-focused apps (e.g., graphics tools, DB management systems)             |
| **Web Applications**       | Network-centric, accessed via browsers                                          |
| **AI Software**            | Uses algorithms to solve complex/non-numeric problems                           |

---

## ðŸ› ï¸ Software Engineering  

### ðŸ“– Definitions  

> [!important] **Definitions of Software Engineering**  
> - **Seminal:** Use sound engineering principles to build reliable, economical software.  
> - **IEEE:** Application of systematic, disciplined, quantifiable approaches to development, operation & maintenance.  
> - **Continuation:** Concerned with **all aspects** of production â€” from design to maintenance.  

---

### ðŸ—ï¸ Product Characteristics  

| **Characteristic**           | **Description**                                                                 |
| ---------------------------- | ------------------------------------------------------------------------------- |
| **Maintainability**          | Evolves to meet changing customer needs                                         |
| **Dependability & Security** | Includes reliability, safety, and protection against threats                    |
| **Efficiency**               | Software should not waste system resources                                      |
| **Acceptability**            | Must be acceptable to intended users (usability, suitability, expectations)     |

---

### âš–ï¸ Ethical Principles (8)  

> [!tip] **The 8 Principles**  
> 1. **Public** â†’ act consistently with public interest: safety, privacy, societal well-being  
> 2. **Client & Employer** â†’ serve faithfully, without compromising public interest  
> 3. **Product** â†’ ensure software meets highest professional standards  
> 4. **Judgement** â†’ maintain integrity & independence in professional decisions  
> 5. **Management** â†’ promote ethical project management practices  
> 6. **Profession** â†’ uphold integrity & reputation of the field  
> 7. **Colleagues** â†’ treat colleagues fairly, support growth  
> 8. **Self** â†’ lifelong learning & competence improvement  

---

### ðŸ›ï¸ Layers of Software Engineering  

> [!note] **4 Core Layers**  
> 1. **Tools** â†’ provide automated/semi-automated support for process & methods.  
>     - When tools are integrated so information flows between them â†’ **CASE (Computer-Aided Software Engineering)** is established.  
> 2. **Methods** â†’ technical activities: communication, requirements analysis, design modeling, program construction, testing, support.  
> 3. **Process Model** â†’ framework required for effective delivery; forms basis of project management control.  
> 4. **Quality Focus** â†’ foundation that underpins all other layers.  

---

### ðŸ”„ Software Engineering Concepts  

> [!important] **Generic Process Model**  
> - **Communication** â†’ gather requirements  
> - **Planning** â†’ estimate effort, cost, scheduling  
> - **Modeling** â†’ create design models & specifications  
> - **Construction** â†’ coding & testing  
> - **Deployment** â†’ delivery & ongoing maintenance  

> [!important] **Process Flow Types**  
> - **Linear** â†’ step-by-step, sequential  
> - **Iterative** â†’ repeat stages when needed  
> - **Evolutionary** â†’ circular, grows system with each cycle  
> - **Parallel** â†’ multiple activities proceed simultaneously  

> [!important] **Umbrella Activities**  
> - Span all phases of software lifecycle  
> - Examples: quality assurance, documentation, configuration management, project management  

---

### ðŸ§© Process Models  

| **Model**       | **Key Idea**                                                                 |
| --------------- | ---------------------------------------------------------------------------- |
| **Waterfall**   | Classic, sequential: requirements â†’ design â†’ code â†’ test â†’ deploy            |
| **Incremental** | Linear sequences delivered in increments; staggered development              |
| **RAD**         | Incremental model with parallel mini-projects, time-boxed & assembled        |
| **Prototype**   | Quick mock-up to refine requirements; includes throwaway prototypes          |
| **Spiral**      | Combines prototyping + waterfall, risk-driven, uses **anchor milestones**    |
| **Concurrent**  | Concurrent engineering: activities exist in parallel but in different states |
| **Agile**       | Flexible, iterative, customer-focused; values collaboration & adaptability   |

---

#### ðŸ” Expanded Model Details  

- **Waterfall Model**  
  Sequential, systematic approach starting with specs/requirements and progressing through planning, modeling, construction, deployment.  

- **Incremental Model**  
  Combination of linear + parallel flow. Work divided into increments, each delivering usable functionality.  

- **RAD (Rapid Application Development)**  
  - Incremental approach with parallel mini-projects.  
  - Teams develop components simultaneously.  
  - Time-boxed development â†’ delivered & assembled.  

- **Prototype Model**  
  - Based on currently known requirements.  
  - Client can "feel" the system early.  
  - Throwaway prototypes â†’ used to understand requirements, not as final design.  

- **Spiral Model**  
  - Proposed by **Barry Boehm**.  
  - Evolutionary: combines iterative prototyping with structured waterfall aspects.  
  - Enables rapid development of increasingly complete versions.  
  - **Two key features:**  
    1. **Cyclic approach** â†’ grow definition & implementation, reduce risk.  
    2. **Anchor-point milestones** â†’ ensure stakeholder commitment & feasible solutions.  

- **Concurrent Model**  
  - Also called **Concurrent Engineering**.  
  - Activities occur concurrently but reside in different states (e.g., awaiting, under development, under review).  

- **Agile Model**  
  - Flexible, iterative, and **customer-focused**.  
  - Values collaboration, working software, adaptability over rigid planning and documentation.  

---

> [!tip] ðŸ“˜ Test your knowledge  
[[Introduction Practice Quiz]]  
