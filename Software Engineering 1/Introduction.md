# 📘 Software & Software Engineering  
	
## 🖥️ Software  

> [!note] **What is Software?**  
> - **Instructions** → computer programs  
> - **Data structures** → store & manipulate information  
> - **Documentation** → describes operation & usage  

---

### 📂 Categories of Software  

| **Category**               | **Description**                                                                 |
| -------------------------- | ------------------------------------------------------------------------------- |
| **System**                 | Manages hardware & system operations (e.g., compilers, editors, file utilities) |
| **Application**            | End-user tasks (e.g., word processors, accounting software)                      |
| **Engineering/Scientific** | Heavy computation (e.g., stress analysis, molecular modeling)                   |
| **Embedded**               | Built into devices for control (e.g., microwave, car dashboard)                 |
| **Product-Line**           | Consumer-focused apps (e.g., graphics tools, DB management systems)             |
| **Web Applications**       | Network-centric, accessed via browsers                                          |
| **AI Software**            | Uses algorithms to solve complex/non-numeric problems                           |

---

## 🛠️ Software Engineering  

### 📖 Definitions  

> [!important] **Definitions of Software Engineering**  
> - **Seminal:** Use sound engineering principles to build reliable, economical software.  
> - **IEEE:** Application of systematic, disciplined, quantifiable approaches to development, operation & maintenance.  
> - **Continuation:** Concerned with **all aspects** of production — from design to maintenance.  

---

### 🏗️ Product Characteristics  

| **Characteristic**           | **Description**                                                                 |
| ---------------------------- | ------------------------------------------------------------------------------- |
| **Maintainability**          | Evolves to meet changing customer needs                                         |
| **Dependability & Security** | Includes reliability, safety, and protection against threats                    |
| **Efficiency**               | Software should not waste system resources                                      |
| **Acceptability**            | Must be acceptable to intended users (usability, suitability, expectations)     |

---

### ⚖️ Ethical Principles (8)  

> [!tip] **The 8 Principles**  
> 1. **Public** → act consistently with public interest: safety, privacy, societal well-being  
> 2. **Client & Employer** → serve faithfully, without compromising public interest  
> 3. **Product** → ensure software meets highest professional standards  
> 4. **Judgement** → maintain integrity & independence in professional decisions  
> 5. **Management** → promote ethical project management practices  
> 6. **Profession** → uphold integrity & reputation of the field  
> 7. **Colleagues** → treat colleagues fairly, support growth  
> 8. **Self** → lifelong learning & competence improvement  

---

### 🏛️ Layers of Software Engineering  

> [!note] **4 Core Layers**  
> 1. **Tools** → provide automated/semi-automated support for process & methods.  
>     - When tools are integrated so information flows between them → **CASE (Computer-Aided Software Engineering)** is established.  
> 2. **Methods** → technical activities: communication, requirements analysis, design modeling, program construction, testing, support.  
> 3. **Process Model** → framework required for effective delivery; forms basis of project management control.  
> 4. **Quality Focus** → foundation that underpins all other layers.  

---

### 🔄 Software Engineering Concepts  

> [!important] **Generic Process Model**  
> - **Communication** → gather requirements  
> - **Planning** → estimate effort, cost, scheduling  
> - **Modeling** → create design models & specifications  
> - **Construction** → coding & testing  
> - **Deployment** → delivery & ongoing maintenance  

> [!important] **Process Flow Types**  
> - **Linear** → step-by-step, sequential  
> - **Iterative** → repeat stages when needed  
> - **Evolutionary** → circular, grows system with each cycle  
> - **Parallel** → multiple activities proceed simultaneously  

> [!important] **Umbrella Activities**  
> - Span all phases of software lifecycle  
> - Examples: quality assurance, documentation, configuration management, project management  

---

### 🧩 Process Models  

| **Model**       | **Key Idea**                                                                 |
| --------------- | ---------------------------------------------------------------------------- |
| **Waterfall**   | Classic, sequential: requirements → design → code → test → deploy            |
| **Incremental** | Linear sequences delivered in increments; staggered development              |
| **RAD**         | Incremental model with parallel mini-projects, time-boxed & assembled        |
| **Prototype**   | Quick mock-up to refine requirements; includes throwaway prototypes          |
| **Spiral**      | Combines prototyping + waterfall, risk-driven, uses **anchor milestones**    |
| **Concurrent**  | Concurrent engineering: activities exist in parallel but in different states |
| **Agile**       | Flexible, iterative, customer-focused; values collaboration & adaptability   |

---

#### 🔍 Expanded Model Details  

- **Waterfall Model**  
  Sequential, systematic approach starting with specs/requirements and progressing through planning, modeling, construction, deployment.  

- **Incremental Model**  
  Combination of linear + parallel flow. Work divided into increments, each delivering usable functionality.  

- **RAD (Rapid Application Development)**  
  - Incremental approach with parallel mini-projects.  
  - Teams develop components simultaneously.  
  - Time-boxed development → delivered & assembled.  

- **Prototype Model**  
  - Based on currently known requirements.  
  - Client can "feel" the system early.  
  - Throwaway prototypes → used to understand requirements, not as final design.  

- **Spiral Model**  
  - Proposed by **Barry Boehm**.  
  - Evolutionary: combines iterative prototyping with structured waterfall aspects.  
  - Enables rapid development of increasingly complete versions.  
  - **Two key features:**  
    1. **Cyclic approach** → grow definition & implementation, reduce risk.  
    2. **Anchor-point milestones** → ensure stakeholder commitment & feasible solutions.  

- **Concurrent Model**  
  - Also called **Concurrent Engineering**.  
  - Activities occur concurrently but reside in different states (e.g., awaiting, under development, under review).  

- **Agile Model**  
  - Flexible, iterative, and **customer-focused**.  
  - Values collaboration, working software, adaptability over rigid planning and documentation.  

---

> [!tip] 📘 Test your knowledge  
[[Introduction Practice Quiz]]  
